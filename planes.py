#!/usr/bin/env python
import os
import sys
import time
import itertools
import json
import math
import logging
import pprint

from typing import TypeAlias

from skspatial.objects import Plane, Points, LineSegment

import numpy as np
from SetCoverPy import setcover  #type: ignore
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.axes3d import Axes3D

import off

PlaneSet:TypeAlias = set[frozenset[int]]

logging.captureWarnings(True)

tolerance = 1e-12
planes_file = "planes-distance_point.jsonl"
from names import mesh_root
mcp_file = "minimum_covering_planes.jsonl"
db_file = "solutions.json"


def json_set_default(obj):
    if isinstance(obj, (set, frozenset)):
        return list(obj)
    raise TypeError


def find_planes(meshes:dict[int,off.Mesh], planes_file=planes_file) -> None:
    """find all sets of coplanar vertices for all meshes and save it to the planes_file"""
    _st = time.time()

    with open(planes_file, "w") as f:
        f.write(json.dumps({"tolerance": tolerance}) + "\n")

    for j_number, mesh in meshes.items():
        f_errors = {}
        for f in mesh.faces:
            if len(f.points) > 3:
                points = Points(f.points_array())
                if not points.are_coplanar(tol=tolerance):
                    plane_points = Plane.from_points(f.points[0].coords, f.points[1].coords, f.points[2].coords)
                    distances = []
                    for p in f.points[3:]:
                        d = plane_points.distance_point_signed(p.coords)
                        distances.append(float(f"{d:.2e}"))
                    f_errors[f.index] = distances
        if f_errors:
            print(f"J{j_number} has nonplanar faces: {f_errors}")
            with open(planes_file, "a") as f:
                f.write(json.dumps({
                    "j_number": j_number,
                    "error": "nonplanar_faces",
                    "error_nonplanar_faces": f_errors
                }) + "\n")
            continue # don't even try to find planes

        # find planes...
        planes:PlaneSet = set()
        plane_max_points = 0

        # add faces as planes
        for f in mesh.faces:
            planes.add(frozenset(v.index for v in f.points))

        # find non-face planes
        start_time = time.time()
        point_nums = set(range(len(mesh.points)))
        for combo in (set(c) for c in itertools.combinations(point_nums, 3)):
            if any(combo <= p for p in planes):
                continue # already have this combo

            plane:Plane = Plane.from_points(*[mesh.points[i].coords for i in combo])
            plane_points = combo.copy()

            for i in (point_nums - combo):
                if plane.distance_point(mesh.points[i].coords) < tolerance:
                # if Points([mesh.points[j].coords for j in (combo | {i})]).are_coplanar(tol=tolerance):
                    plane_points.add(i)

            planes.add(frozenset(plane_points))
            plane_max_points = max(plane_max_points, len(plane_points))

        t = round(time.time() - start_time, 2)
        print(f"[J{j_number}] faces: {len(mesh.faces)}\t\tbiggest: {max(len(f.points) for f in mesh.faces)}\tplanes: {len(planes)}\tmax points: {plane_max_points}\ttime: {t}")
        with open(planes_file, "a") as f:
            f.write(json.dumps({
                "j_number": j_number,
                "t": t,
                "planes": [list(p) for p in planes]
            }, separators=(',', ':')) + "\n")

    print(time.time() - _st)


def load_planes(planes_file=planes_file) -> dict[int,PlaneSet]:
    """load a file previously generated by find_planes"""
    solids_planes:dict[int,PlaneSet] = {}
    with open(planes_file) as f:
        for line in f:
            data = json.loads(line)
            if "tolerance" in data:
                print(f"{planes_file} generated with tolerance={data['tolerance']}")
            elif "error" in data:
                print(data)
            else:
                solids_planes[data["j_number"]] = set(frozenset(i) for i in data["planes"])
    return solids_planes


def equal_planes(a:dict[int,PlaneSet], b:dict[int,PlaneSet]) -> bool:
    """check if the given plane set collections are equal"""
    #todo?: show differences?
    return a == b  # lol


def load_meshes(folder=mesh_root) -> dict[int,off.Mesh]:
    """load all .off mesh files in the given directory"""
    meshes:dict[int,off.Mesh] = {}
    fullnames = []
    for fname in os.listdir(folder):
        fullname = os.path.join(folder, fname)
        if fullname.endswith(".off") and os.path.isfile(fullname):
            fullnames.append((int(fname.split("_",1)[0][1:]), fullname))

    for j_number, fullname in sorted(fullnames):
        meshes[j_number] = off.Mesh.load(fullname, info=True)

    return meshes


def find_starting_bssf(mesh:off.Mesh, j_number:int=None, print_=False) -> tuple[int,str]:
    """find an upper bound for mimimum set cover"""  # this might be more useful if I decided to write my own set-cover algorithm
    v_over_3 = math.ceil(len(mesh.points) / 3)
    unique_x = len(set(v.x for v in mesh.points))
    unique_y = len(set(v.y for v in mesh.points))
    unique_z = len(set(v.z for v in mesh.points))
    values = (v_over_3, unique_x, unique_y, unique_z)
    bssf = min(values)

    reason = ""
    if v_over_3 == bssf:
        reason += " v/3"
    if unique_x == bssf:
        reason += " unique_x"
    if unique_y == bssf:
        reason += " unique_y"
    if unique_z == bssf:
        reason += " unique_z"

    if print_:
        msg = f"J{j_number} {values} | starting bssf = {bssf} | from:"
        print(msg + reason)
    return (bssf, reason.strip())


def find_bins(all_planes:dict[int,PlaneSet]) -> None:
    """find the number of planes of each size (number of covered points) for each plane set and save it as a .csv"""
    bins:dict[int,dict[int,int]] = {}
    for j_number, planes in all_planes.items():
        bins[j_number] = {}
        for p in planes:
            s = len(p)
            if s not in bins[j_number]:
                bins[j_number][s] = 0
            bins[j_number][s] += 1
    m = max(max(x.keys()) for x in bins.values())

    with open("bins.csv", "w") as f:
        f.write(f"J,{','.join(str(b) for b in range(3,m+1))},total\n")
        for j in bins:
            f.write(f"{j},{','.join(str(bins[j][b] if b in bins[j] else 0) for b in range(3,m+1))},{len(all_planes[j])}\n")


def minimum_covering_planes(mesh:off.Mesh, planes_set:PlaneSet, j_number:int=None) -> tuple[int,PlaneSet,int]:
    planes_list = list(planes_set)
    plane_sort_key = lambda x: (len(x), sorted(x))
    planes_list.sort(key=plane_sort_key, reverse=True)

    matrix = np.zeros((len(planes_set), len(mesh.points)), dtype=np.byte)
    for i in range(len(planes_list)):
        for j in planes_list[i]:
            matrix[i,j] = 1

    sc = setcover.SetCover(matrix.T, np.ones((len(planes_list),), dtype=np.byte), 40, 30, 200)
    solution_size, minutes = sc.SolveSCP()

    try:
        assert solution_size <= find_starting_bssf(mesh)[0]
    except:
        print(f"found solution {solution_size} is worse than upper bound {find_starting_bssf(mesh)}")

    solution_set_indexes = [int(i) for i in range(len(sc.s)) if sc.s[i]]
    solution = set(planes_list[i] for i in solution_set_indexes)
    return (int(solution_size), solution, minutes*60)


def find_all_mcp(meshes:dict[int,off.Mesh], all_planes:dict[int,PlaneSet], outfile=mcp_file):
    with open(outfile, "w") as f:
        pass

    for j in meshes:
        mesh = meshes[j]
        planes = all_planes[j]
        count, solution, t_seconds = minimum_covering_planes(mesh, planes, j)
        print(f"[J{j}] {t_seconds:.2f}s {count} {[list(p) for p in solution]}")
        with open(outfile, "a") as f:
            f.write(json.dumps({
                "j_number": j,
                "t": round(t_seconds, 2),
                "count": count,
                "planes": [list(p) for p in solution]
            }) + "\n")


def create_db_from_mcp_files(mcp_files:list[str], meshes:dict[int,off.Mesh], db_file=db_file):
    db = {}
    for j in meshes:
        sbssf, reason = find_starting_bssf(meshes[j])
        db[j] = {
            "j_number": j,
            "sbssf": sbssf,
            "sbssf_reason": reason,
            "bssf": None,
            "num_solutions": 0,
            "solutions": set()
        }

    for fname in mcp_files:
        with open(fname) as f:
            for line in f:
                data = json.loads(line)
                j = data["j_number"]
                count = data["count"]
                planes = frozenset(frozenset(i) for i in data["planes"])
                assert count == len(planes)

                if db[j]["bssf"] is None:
                    db[j]["bssf"] = count
                    db[j]["solutions"] = set([planes])
                    db[j]["num_solutions"] = 1
                    print(f"Found solution for J{j}: {count}")
                elif count < db[j]["bssf"]:
                    db[j]["bssf"] = count
                    db[j]["solutions"] = set([planes])
                    db[j]["num_solutions"] = 1
                    print(f"Found better solution for J{j}: {count}")
                elif db[j]["bssf"] == count and planes not in db[j]["solutions"]:
                    db[j]["solutions"].add(planes)
                    db[j]["num_solutions"] += 1
                    print(f"\tFound alternate solution for J{j}: {count}")

    with open(db_file, "w") as f:
        f.write(pprint.pformat(json.loads(json.dumps(db, default=json_set_default)), width=120, sort_dicts=False).replace("'", '"'))  # this is utterly cursed. don't do this
        # json.dump(db, f, default=json_set_default)


def plot_mesh(mesh:off.Mesh, plane_ind:frozenset[int]):
    ax:Axes3D
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

    p = Points(mesh.points_array())
    p.plot_3d(ax, color="black")

    for e in mesh.edges:
        ls = LineSegment(e.p0.coords, e.p1.coords)
        ls.plot_3d(ax, color="gray", lw=1)

    ax.set_aspect("equal")
    xmin, xmax, ymin, ymax, zmin, zmax = ax.get_w_lims()

    plane = Plane.from_points(*[mesh.points[i].coords for i in list(plane_ind)[:3]])
    plane.plot_3d(ax, (xmin-plane.point[0], xmax-plane.point[0]), (ymin-plane.point[1], ymax-plane.point[1]), color="#0f0f0f80")

    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_zlim(zmin, zmax)

    plt.show()


if __name__ == "__main__":
    if sys.argv[1][0] == "f":
        find_planes(load_meshes())

    elif sys.argv[1][0] == "e":
        print(equal_planes(load_planes(sys.argv[2]), load_planes(sys.argv[3])))

    elif sys.argv[1][0] == "m":
        find_all_mcp(load_meshes(), load_planes())

    elif sys.argv[1][0] == "l":
        planes = load_planes()
        for j_number in planes:
            print(f"J{j_number}: {len(planes[j_number])} planes")

    elif sys.argv[1][0] == "s":
        meshes = load_meshes()
        for j in meshes:
            find_starting_bssf(meshes[j], j, True)

    elif sys.argv[1][0] == "b":
        find_bins(load_planes())

    elif sys.argv[1][0] == "d":
        create_db_from_mcp_files(
            ["minimum_covering_planes1.jsonl",
            "minimum_covering_planes2.jsonl",
            "minimum_covering_planes3.jsonl",
            "minimum_covering_planes4.jsonl",
            "minimum_covering_planes5.jsonl",
            "minimum_covering_planes6.jsonl",
            "minimum_covering_planes.jsonl",],
            load_meshes())

    elif sys.argv[1][0] == "3":
        meshes = load_meshes()
        # plot_mesh(meshes[int(sys.argv[2])])
        plot_mesh(meshes[6], frozenset([5, 6, 7, 8, 9]))
